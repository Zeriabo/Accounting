{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst react_1 = __importStar(require(\"react\")); // Keeps track of how many requests are currently active.\n\n\nexports.activeRequests = 0;\n\nclass ProgressBar extends react_1.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      mode: 'hibernate'\n    };\n  } // Set the reference to progressBar\n\n\n  componentDidMount() {\n    exports.progressBar = this;\n  } // Only render if the mode changes\n\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextState.mode !== this.state.mode;\n  }\n  /**\n   * The ProgressBar continuously checks the status of how many\n   * requests are currently active, and will accordingly move\n   * to another state.\n   *\n   * @memberof ProgressBar\n   */\n\n\n  tick() {\n    const mode = this.state.mode;\n\n    if (mode === 'complete') {\n      //console.log('complete: moving to hibernate after 1 second to allow the close animation to complete');\n      setTimeout(() => {\n        this.setState({\n          mode: 'hibernate'\n        });\n      }, 1000);\n    } else if (mode === 'active') {\n      if (exports.activeRequests === 0) {\n        //console.log('active: there are no more pending request move to complete if there are still no pending requests after 200 milliseconds');\n        setTimeout(() => {\n          if (exports.activeRequests === 0) {\n            //console.log('active: even after 200 milliseconds there are no more pending request, moving to complete');\n            this.moveToMode('complete');\n          } else {\n            //console.log('active: after 200 milliseconds another request was pending instead of going to complete will stay active.');\n            this.tick();\n          }\n        }, 200);\n      } else {\n        //console.log('active: there are still pending requests staying active');\n        this.tickWithDelay();\n      }\n    } else {\n      // mode === 'init'\n      if (exports.activeRequests > 0) {\n        //console.log('init: there are pending request move to active if there are still pending requests after 100 milliseconds');\n        setTimeout(() => {\n          if (exports.activeRequests > 0) {\n            //console.log('init: even after 100 milliseconds there are pending request, moving to active to trigger animation');\n            this.moveToMode('active');\n          } else {\n            //console.log('init: after 100 milliseconds there were no pending request, the requests was so fast that showing an animation is unnecessary, move to hibernate');\n            this.setState({\n              mode: 'hibernate'\n            });\n          }\n        }, 100);\n      } else {\n        //console.log('init: no pending requests move to hibernate');\n        this.setState({\n          mode: 'hibernate'\n        });\n      }\n    }\n  }\n\n  moveToInit() {\n    if (this.state.mode === 'hibernate') {\n      this.moveToMode('init');\n    }\n  }\n\n  moveToMode(mode) {\n    this.setState({\n      mode\n    }, () => {\n      this.tick();\n    });\n  }\n\n  tickWithDelay() {\n    setTimeout(() => {\n      this.tick();\n    }, 50);\n  }\n\n  render() {\n    const mode = this.state.mode;\n\n    if (mode === 'hibernate') {\n      return null;\n    }\n\n    const width = mode === 'complete' ? 100 : mode === 'init' ? 0 : 80;\n    const animationSpeed = mode === 'complete' ? 0.8 : 30;\n    const transition = mode === 'init' ? '' : `width ${animationSpeed}s ease-in`;\n    const style = Object.assign({\n      position: 'absolute',\n      top: '0',\n      zIndex: 9000,\n      backgroundColor: '#f0ad4e',\n      height: '4px',\n      transition,\n      width: `${width}%`\n    }, this.props.style);\n    return react_1.default.createElement(\"div\", {\n      className: \"react-fetch-progress-bar\",\n      style: style\n    });\n  }\n\n}\n\nexports.ProgressBar = ProgressBar; // We store the fetch here as provided by the user.\n\nlet originalFetch;\n\nfunction setOriginalFetch(nextOriginalFetch) {\n  originalFetch = nextOriginalFetch;\n}\n\nexports.setOriginalFetch = setOriginalFetch;\n/**\n * Wrapper around fetch: https://developer.mozilla.org/en/docs/Web/API/Fetch_API\n *\n * It is used to monitor the number of requests which are currently\n * active. Each time a requests is made it increases the number of\n * requests, each time a request is finished, the number is decreased.\n *\n * @export\n * @param {string} url The url you want to send a request to.\n * @param {RequestOptions} [options] The options you want to pass for that request\n * @returns {Promise<Response>} A Promise which returns a Response\n */\n\nfunction progressBarFetch(url, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    exports.activeRequests += 1;\n\n    if (exports.progressBar) {\n      exports.progressBar.moveToInit();\n    }\n\n    try {\n      const response = yield originalFetch(url, options);\n      exports.activeRequests -= 1;\n      return response;\n    } catch (error) {\n      exports.activeRequests -= 1;\n      return Promise.reject(error);\n    }\n  });\n}\n\nexports.progressBarFetch = progressBarFetch;\n/**\n * Sets the number of activeRequests manually.\n *\n * This method exists for testing purposes, so you should not\n * use it.\n *\n * @export\n * @param {number} nextActiveRequest\n */\n\nfunction setActiveRequests(nextActiveRequest) {\n  exports.activeRequests = nextActiveRequest;\n}\n\nexports.setActiveRequests = setActiveRequests;","map":{"version":3,"sources":["/home/zeriab/Desktop/Project/merncaccounting/node_modules/react-fetch-progressbar/lib/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__importStar","mod","__esModule","k","Object","hasOwnProperty","call","defineProperty","exports","react_1","require","activeRequests","ProgressBar","Component","constructor","arguments","state","mode","componentDidMount","progressBar","shouldComponentUpdate","nextProps","nextState","tick","setTimeout","setState","moveToMode","tickWithDelay","moveToInit","render","width","animationSpeed","transition","style","assign","position","top","zIndex","backgroundColor","height","props","default","createElement","className","originalFetch","setOriginalFetch","nextOriginalFetch","progressBarFetch","url","options","response","error","setActiveRequests","nextActiveRequest"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = __importStar(require(\"react\"));\n// Keeps track of how many requests are currently active.\nexports.activeRequests = 0;\nclass ProgressBar extends react_1.Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            mode: 'hibernate',\n        };\n    }\n    // Set the reference to progressBar\n    componentDidMount() {\n        exports.progressBar = this;\n    }\n    // Only render if the mode changes\n    shouldComponentUpdate(nextProps, nextState) {\n        return nextState.mode !== this.state.mode;\n    }\n    /**\n     * The ProgressBar continuously checks the status of how many\n     * requests are currently active, and will accordingly move\n     * to another state.\n     *\n     * @memberof ProgressBar\n     */\n    tick() {\n        const mode = this.state.mode;\n        if (mode === 'complete') {\n            //console.log('complete: moving to hibernate after 1 second to allow the close animation to complete');\n            setTimeout(() => {\n                this.setState({ mode: 'hibernate' });\n            }, 1000);\n        }\n        else if (mode === 'active') {\n            if (exports.activeRequests === 0) {\n                //console.log('active: there are no more pending request move to complete if there are still no pending requests after 200 milliseconds');\n                setTimeout(() => {\n                    if (exports.activeRequests === 0) {\n                        //console.log('active: even after 200 milliseconds there are no more pending request, moving to complete');\n                        this.moveToMode('complete');\n                    }\n                    else {\n                        //console.log('active: after 200 milliseconds another request was pending instead of going to complete will stay active.');\n                        this.tick();\n                    }\n                }, 200);\n            }\n            else {\n                //console.log('active: there are still pending requests staying active');\n                this.tickWithDelay();\n            }\n        }\n        else {\n            // mode === 'init'\n            if (exports.activeRequests > 0) {\n                //console.log('init: there are pending request move to active if there are still pending requests after 100 milliseconds');\n                setTimeout(() => {\n                    if (exports.activeRequests > 0) {\n                        //console.log('init: even after 100 milliseconds there are pending request, moving to active to trigger animation');\n                        this.moveToMode('active');\n                    }\n                    else {\n                        //console.log('init: after 100 milliseconds there were no pending request, the requests was so fast that showing an animation is unnecessary, move to hibernate');\n                        this.setState({ mode: 'hibernate' });\n                    }\n                }, 100);\n            }\n            else {\n                //console.log('init: no pending requests move to hibernate');\n                this.setState({ mode: 'hibernate' });\n            }\n        }\n    }\n    moveToInit() {\n        if (this.state.mode === 'hibernate') {\n            this.moveToMode('init');\n        }\n    }\n    moveToMode(mode) {\n        this.setState({ mode }, () => {\n            this.tick();\n        });\n    }\n    tickWithDelay() {\n        setTimeout(() => {\n            this.tick();\n        }, 50);\n    }\n    render() {\n        const mode = this.state.mode;\n        if (mode === 'hibernate') {\n            return null;\n        }\n        const width = mode === 'complete' ? 100 : mode === 'init' ? 0 : 80;\n        const animationSpeed = mode === 'complete' ? 0.8 : 30;\n        const transition = mode === 'init' ? '' : `width ${animationSpeed}s ease-in`;\n        const style = Object.assign({ position: 'absolute', top: '0', zIndex: 9000, backgroundColor: '#f0ad4e', height: '4px', transition, width: `${width}%` }, this.props.style);\n        return react_1.default.createElement(\"div\", { className: \"react-fetch-progress-bar\", style: style });\n    }\n}\nexports.ProgressBar = ProgressBar;\n// We store the fetch here as provided by the user.\nlet originalFetch;\nfunction setOriginalFetch(nextOriginalFetch) {\n    originalFetch = nextOriginalFetch;\n}\nexports.setOriginalFetch = setOriginalFetch;\n/**\n * Wrapper around fetch: https://developer.mozilla.org/en/docs/Web/API/Fetch_API\n *\n * It is used to monitor the number of requests which are currently\n * active. Each time a requests is made it increases the number of\n * requests, each time a request is finished, the number is decreased.\n *\n * @export\n * @param {string} url The url you want to send a request to.\n * @param {RequestOptions} [options] The options you want to pass for that request\n * @returns {Promise<Response>} A Promise which returns a Response\n */\nfunction progressBarFetch(url, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        exports.activeRequests += 1;\n        if (exports.progressBar) {\n            exports.progressBar.moveToInit();\n        }\n        try {\n            const response = yield originalFetch(url, options);\n            exports.activeRequests -= 1;\n            return response;\n        }\n        catch (error) {\n            exports.activeRequests -= 1;\n            return Promise.reject(error);\n        }\n    });\n}\nexports.progressBarFetch = progressBarFetch;\n/**\n * Sets the number of activeRequests manually.\n *\n * This method exists for testing purposes, so you should not\n * use it.\n *\n * @export\n * @param {number} nextActiveRequest\n */\nfunction setActiveRequests(nextActiveRequest) {\n    exports.activeRequests = nextActiveRequest;\n}\nexports.setActiveRequests = setActiveRequests;\n"]},"metadata":{},"sourceType":"script"}